# 依赖管理工具

## 一、Go Modules

### 1、什么是go modules?



Go Modules 是在 Go 编程语言中引入的一种包管理系统，它解决了 Go 语言早期版本在依赖管理方面的一些局限性和痛点。它于 Go 1.11 版本首次推出，并在 Go 1.13 中正式成为默认的依赖管理方式。以下是 Go Modules 产生的背景以及解决的问题



### 2、为什么引入go modules



#### Go Path的缺点

* GOPATH 的限制

  * 早期的 Go 工程必须位于 GOPATH 环境变量指定的目录下，这对开发者的工程组织造成了限制。
  * 所有项目共用一个 GOPATH，导致依赖版本之间可能产生冲突（不同项目依赖同一个包的不同版本时，难以单独管理）
    * GOPATH目录下一共包含了三个子目录，分别是：
      * bin：存储所编译生成的二进制文件。
      * pkg：存储预编译的目标文件，以加快程序的后续编译速度。
      * src：存储所有.go文件或源代码。在编写 Go 应用程序，程序包和库时，一般会以$GOPATH/src/github.com/foo/bar的路径进行存放



* 依赖版本控制不够完善

  * 在 Go Modules 之前，Go 社区使用工具如 dep、glide 或 go vendor 来手动管理依赖，但这些工具并没有官方支持
  * 很多工程直接通过 go get 下载最新版本的依赖，这可能导致构建不可重复，因为依赖包的版本是浮动的



* 依赖的不可重复性

  * 缺乏明确的依赖版本声明和版本锁定机制，导致在不同时间或环境中构建可能得不到相同的结果。



* 版本语义化支持不足

  * 早期的依赖管理对语义化版本（Semantic Versioning）支持不够，开发者难以区分重大版本更新、次要更新或补丁更新
  * 什么是**语义化版本**？语义化版本是一套由 Gravatars 创办者兼 GitHub 共同创办者 Tom Preston-Werner 所建立的约定。在这套约定下，语义化版本号及其更新方式包含了很多有用的信息
  * 语义化版本号格式为：`X.Y.Z`（主版本号.次版本号.修订号），使用方法如下
    * 进行不向下兼容的修改时，递增主版本号
    * API 保持向下兼容的新增及修改时，递增次版本号
    * 修复问题但不影响 API 时，递增修订号





#### Go Modules作用

* 脱离 GOPATH

  * 开发者可以将项目放在任意目录下，不再需要位于 GOPATH 中。
* 提供更灵活的工程组织方式，适应不同团队和开发者的需求



* 明确的依赖管理

  * 使用 go.mod 文件记录模块名称和依赖的精确版本。
  * go.sum 文件提供依赖包的哈希值，用于验证依赖的完整性。



* 支持语义化版本

  * Go Modules 强调语义化版本（Semantic Versioning，简写为 SemVer），使依赖管理更规范化
  * 模块版本号以 vX.Y.Z 格式标记，重大版本更新可以通过版本号区分

  

* 增强构建的可重复性

  * 通过依赖锁定（go.sum）和版本校验，确保在不同环境或时间点构建时的结果一致性



* 高效的模块代理支持

  * 引入 Go Module Proxy（例如 proxy.golang.org）来缓存和加速模块的下载，提高开发体验和构建效率。





### 3、Go Modules 的组成

* go.mod 文件

  * 声明模块的名称和依赖的版本，例如:

    ```go
    module my_project  // 定义模块路径。
    
    go 1.20  // 设置预期的语言版本。
    
    require (
        github.com/gin-gonic/gin v1.8.1
        github.com/sirupsen/logrus v1.9.0
    )
    // require：要求给定版本或更高版本的特定模块
    // exclude：排除特定版本模块的使用，不允许的模块版本被视为不可用，并且查询无法返回
    // replace：使用不同的模块版本替换原有模块版本
    // 对于2.0.0及以上版本，上述模块路径需要加上主版本号 例如:github.com/go-redis/redis/v8 v8.11.5 // indirect
    ```
    
    

* go.sum 文件

  * 记录依赖包及其所有递归依赖的哈希值，用于校验模块的完整性





### 4、**GOPATH 变量会被移除吗？**

不会，GOPATH 变量不会被移除。未来废弃 GOPATH 开发模式并不是指删除 GOPATH 环境变量，它会继续保留，主要作用如下：

- go install 命令安装二进制到 $GOBIN 目录，其默认位置为 $GOPATH/bin。
- go get 命令缓存下载的 modules 到 $GOMODCACHE 目录，默认位置为 $GOPATH/pkg/mod。
- go get 命令缓存下载的 checksum 数据到 $GOPATH/pkg/sumdb 目录。





### 5、常用命令

| 命令            | 作用                             |
| --------------- | -------------------------------- |
| go mod init     | 生成 go.mod 文件                 |
| go mod download | 下载 go.mod 文件中指明的所有依赖 |
| go mod tidy     | 整理现有的依赖                   |
| go mod graph    | 查看现有的依赖结构               |
| go mod edit     | 编辑 go.mod 文件                 |
| go mod vendor   | 导出项目所有的依赖到vendor目录   |
| go mod verify   | 校验一个模块是否被篡改过         |
| go mod why      | 查看为什么需要依赖某模块         |



## 二、vendor 目录模式

### 1、vendor 目录的意义

**本地存储依赖包**

- 项目中使用的依赖库的源代码会被直接下载并存放在 `vendor` 目录下。
- 构建时，Go 工具链优先使用 `vendor` 目录中的依赖，而不是从外部网络拉取。



**解决网络依赖问题**

- 一些生产环境可能无法访问外部依赖（例如因防火墙或网络问题）。
- `vendor` 提供了完全离线的依赖管理解决方案。



**版本一致性**

- 通过固定的依赖版本（存储在 `vendor` 中），确保在不同的开发环境和构建阶段依赖一致。



### 2、`vendor` 模式的工作机制



在 Go 1.5 引入 `vendor` 机制后，`vendor` 成为官方支持的依赖管理方案之一。其工作原理如下：



1. 依赖优先级
   - 当编译器解析依赖路径时，会按照以下优先级查找包：
     1. 当前模块的 `vendor` 目录。
     2. `GOROOT`（Go 的标准库目录）。
     3. `GOPATH` 中的依赖。
   
   
   
2. 支持的版本
   - Go 1.5 引入 `vendor`，但需要通过环境变量启用。
   - 从 Go 1.6 开始，`vendor` 默认开启。
   - Go Modules 引入后，`vendor` 的使用不再是主流，但仍被支持，特别是在需要离线构建或固定依赖时。





### 3、使用 `vendor` 目录



在项目中启用 `vendor` 目录时，可以通过以下步骤操作：



**1. 创建 `vendor` 目录**

- 使用依赖管理工具（例如 `go mod`）自动生成 `vendor` 目录。

- 执行命令：

  ```bash
  
  go mod vendor
  ```

  此命令会将所有依赖下载到 vendor目录中。

  

**2. 验证依赖**

- 在本地验证构建是否使用 vendor 目录中的依赖：

  ```bash
  
  go build -mod=vendor
  ```
  
  -mod=vendor 标志强制 Go 使用 vendor 目录中的依赖。
  
  

**3. 直接管理**

- 也可以手动将需要的依赖拷贝到 `vendor` 目录中，但这种方式容易出错，不推荐。



### 4、`vendor` 与 Go Modules 的结合



在 Go Modules 模式下，`vendor` 仍然可以使用，但有以下特性：

1. **自动生成 `vendor`**
   - 使用 `go mod vendor` 命令，根据 `go.mod` 文件中的依赖自动生成。
2. **`go build` 默认行为**
   - 如果不指定 `-mod=vendor`，构建时会直接从模块代理下载依赖。
   - 使用 `-mod=vendor` 标志可以强制使用 `vendor`。
3. **部署场景**
   - 在一些生产环境中，`vendor` 目录可以作为模块的固定依赖快照，避免动态拉取网络依赖。





### 5、适用场景

**企业内网或离线构建**

- 当项目的运行环境不能访问外部网络时，`vendor` 是非常实用的解决方案。

**依赖版本锁定**

- 对于要求严格版本一致性的项目，`vendor` 提供了一种直接的手段。

**兼容非模块化项目**

- 在 Go Modules 之前，`vendor` 是主要的依赖管理模式。





### 6、优缺点

**优点**

- 提供完全的构建独立性，避免外部网络依赖。
- 构建和运行更加稳定和可预测。
- 简化复杂环境中的部署和迁移。

**缺点**

- 依赖会导致代码仓库体积增大，特别是当依赖数量多或体积大时。
- 不如 Go Modules 的代理缓存机制高效。