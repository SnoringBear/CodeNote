# Golang网路

## 一、计算机网络传输格式

在计算机网络中，传输的数据格式多种多样，通常可以根据不同的协议和应用场景进行分类。以下是常见的数据传输格式：

### 1. **文本格式**

- **ASCII（American Standard Code for Information Interchange）**：一种标准字符编码，用于表示英文字母、数字和其他符号。
- **Unicode（UTF-8、UTF-16等）**：用于表示全球多种语言字符的标准编码。
- **JSON（JavaScript Object Notation）**：一种轻量级的数据交换格式，易于人类阅读和机器解析。
- **XML（Extensible Markup Language）**：一种用于存储和传输数据的可扩展标记语言。
- **YAML**：类似于JSON和XML的简洁数据序列化格式。

### 2. **二进制格式**

- **二进制流**：以位或字节序列表示数据，常用于需要高效传输和解析的场景，如音频、视频等多媒体数据。
- **Protobuf（Protocol Buffers）**：一种由Google开发的序列化协议，用于高效传输结构化数据。
- **MessagePack**：一种二进制格式的JSON，旨在高效传输数据。
- **Thrift**：Apache Thrift是跨语言的二进制协议，用于高效的网络通信。

### 3. **媒体格式**

- **图片格式**：如JPEG、PNG、GIF等，用于传输图像数据。
- **音频格式**：如MP3、AAC、WAV等，用于传输音频数据。
- **视频格式**：如MP4、AVI、MKV等，用于传输视频数据。

### 4. **压缩格式**

- **ZIP**：压缩文件格式，用于减少传输文件的大小。
- **GZIP**：用于Web传输的常见压缩格式，特别是在HTTP协议中使用。

### 5. **应用层协议中的数据格式**

- **HTTP/HTTPS**：基于文本的协议，通常传输HTML、JSON、XML等数据。
- **FTP**：用于文件传输的协议，支持多种文件格式的传输。
- **SMTP、IMAP、POP3**：这些协议用于电子邮件的传输，支持文本、HTML邮件以及附件的传输。

### 6. **自定义格式**

- 有些网络应用或系统可能会使用特定于应用程序的数据格式，这种格式由开发者定义，通常基于标准格式加以改进或扩展。

以上这些数据格式在网络传输时会根据具体的协议进行封装和打包，然后通过物理层、数据链路层、网络层等传输到目的地。





## 二、RPC中应用层协议与序列化

在 **RPC（远程过程调用）** 中，**应用层协议**和**序列化**是两个不同的概念，尽管它们经常在一起使用来实现远程通信。理解它们的区别对构建和优化分布式系统非常重要。

### 1. **应用层协议**

应用层协议定义了应用程序之间通信的规则和格式，涉及如何格式化请求和响应消息、处理状态、错误报告、身份验证等。它位于 OSI 模型的最高层，负责管理具体应用程序间的交互方式。

常见的应用层协议：

- **HTTP/HTTPS**：Web 通信的基础协议，常用于 RESTful API、gRPC 等，传输 JSON、XML 或其他序列化格式。
- **gRPC**：基于 HTTP/2，支持双向流和高效的二进制序列化（通常是 Protobuf），用于高性能 RPC。
- **SOAP**：基于 XML 的 Web 服务协议，复杂但功能强大，包含错误处理、状态管理等机制。
- **Thrift**：Apache Thrift 框架提供的一种协议，支持跨语言的 RPC 调用。
- **WebSocket**：应用于双向、长连接的实时通信，支持传输 JSON 或其他格式的数据。

**应用层协议的作用**：

- **请求-响应模型**：定义客户端和服务器之间如何发起请求并响应请求。
- **消息格式**：规定如何封装请求和响应消息，如 HTTP 请求头、状态码等。
- **状态管理**：例如 HTTP 是无状态的协议，服务器不会保存请求的状态，而 gRPC 支持长连接和状态管理。
- **错误处理**：通过状态码或错误消息机制反馈错误信息（如 HTTP 404, 500 错误码）。
- **安全性**：如 HTTPS 提供加密通信以保护传输内容。

在 RPC 系统中，应用层协议负责确保客户端和服务器可以在逻辑上正确通信，传输序列化后的数据，并管理通信过程中的状态、错误和安全性等。

### 2. **序列化**

**序列化**（或编组/编码）是将数据结构或对象转换为可传输的字节流或格式化文本的过程，在 RPC 系统中，它用于将函数的参数、返回值或其他数据转换为可以通过网络传输的格式。反序列化是其逆过程，即将接收到的字节流或格式化文本转换回对象或数据结构。

常见的序列化格式：

- **JSON**：一种基于文本的轻量级数据交换格式，易读、易理解，但性能和效率相对较低。
- **XML**：比 JSON 更复杂的文本序列化格式，具有更强的结构化支持，但冗长且解析速度慢。
- **Protobuf**：Google 开发的一种高效二进制序列化格式，体积小，速度快，适用于高性能的 RPC 调用。
- **Thrift**：Apache 提供的跨语言二进制序列化格式，支持多种语言。
- **MessagePack**：类似于 JSON，但比 JSON 更紧凑，效率更高。

**序列化的作用**：

- **数据编码**：将函数参数、对象或数据结构转换为网络传输的字节流或文本。
- **跨平台兼容性**：确保不同系统和语言可以正确解析和处理数据。
- **高效传输**：一些二进制序列化格式（如 Protobuf）通过压缩和优化，提高了传输效率。
- **解码**：接收端将字节流转换回原始数据结构，以便程序可以正常处理。

在 RPC 系统中，序列化用于封装实际传输的数据，而应用层协议则负责传输这些序列化后的数据，并管理通信过程。

**应用层协议与序列化的区别**

| 特性              | **应用层协议**                           | **序列化**                                   |
| ----------------- | ---------------------------------------- | -------------------------------------------- |
| **作用层次**      | 应用层（网络通信管理）                   | 数据层（数据编码与解码）                     |
| **主要职责**      | 定义应用间通信的规则、消息格式、状态管理 | 将数据结构转换为字节流或格式化文本，便于传输 |
| **功能**          | 管理消息的格式、状态、错误处理、身份验证 | 将复杂的对象或数据结构编码为可传输格式       |
| **传输的内容**    | 序列化后的字节流（或文本）               | 数据对象或参数的字节流                       |
| **可靠性和状态**  | 控制消息的传递、状态管理、错误处理       | 不涉及消息传递的可靠性，只处理数据的转换     |
| **协议/格式类型** | HTTP、gRPC、Thrift、SOAP 等              | JSON、Protobuf、Thrift、XML、MessagePack 等  |
| **性能和效率**    | 影响消息处理的效率、延迟、可靠性         | 影响数据传输的大小、解析速度和网络带宽使用   |
| **例子**          | HTTP、gRPC 定义了如何传递数据            | JSON、Protobuf 决定了如何表示数据            |

**协同工作方式**

- **应用层协议**负责如何在客户端和服务器之间传递消息，以及如何在逻辑上保证通信的正确性。比如，HTTP 定义了客户端和服务器如何发送请求和响应，gRPC 提供了基于 HTTP/2 的双向通信机制。
- **序列化**负责如何将实际的数据转换为字节流或文本格式，以便应用层协议可以传输。例如，gRPC 通常使用 Protobuf 作为序列化格式，而 REST API 通常使用 JSON。

**示例** 

**使用 HTTP 和 JSON 作为 RPC 的传输和序列化方式**：

- **应用层协议**：HTTP 定义请求和响应的格式，包括 HTTP 方法（GET、POST）、请求头、状态码等。
- **序列化**：JSON 用于将请求中的数据和响应中的数据转换为可传输的字符串格式。

```http
POST /api/hello HTTP/1.1
Host: example.com
Content-Type: application/json
Content-Length: 25

{
    "name": "Alice"
}
```

在这个例子中，HTTP 负责管理请求的发送和接收，JSON 负责将数据序列化为可以通过 HTTP 传输的格式。

**使用 gRPC 和 Protobuf 作为 RPC 的传输和序列化方式**：

- **应用层协议**：gRPC 使用 HTTP/2 来传输请求和响应消息，支持双向通信、流控制等特性。
- **序列化**：Protobuf 作为二进制序列化格式，将数据编码为紧凑的二进制格式，以减少带宽使用并提高传输效率。

```protobuf
syntax = "proto3";
service HelloService {
  rpc SayHello (HelloRequest) returns (HelloResponse);
}

message HelloRequest {
  string name = 1;
}

message HelloResponse {
  string message = 1;
}
```

在这个例子中，gRPC 管理通信通道的建立和状态，Protobuf 则负责将 `HelloRequest` 和 `HelloResponse` 转换为二进制格式进行传输。

### **总结**

- **应用层协议**定义了如何在应用程序之间进行通信，规定消息的传递方式、错误处理、状态管理等，是通信的规则制定者。
- **序列化**则负责数据的格式化与编码，将复杂的对象转换为可传输的格式，是数据的表示方式。

两者相辅相成：应用层协议为数据的传输提供了通道和控制机制，序列化则为传输的数据提供了格式化的表示。





## 三、操作系统底层网络例子

在操作系统底层，JSON 格式通过网络传输时，涉及多个网络协议栈和操作系统模块的协同工作。虽然 JSON 本身是纯文本格式，但其实际传输依赖于底层网络协议、系统调用、缓冲区管理等。以下是 JSON 数据在操作系统底层进行网络传输的主要步骤：

### 1. **应用层**：构造和序列化 JSON 数据

在应用层（如浏览器、服务器端程序、移动应用等），应用程序首先会构造 JSON 数据并将其序列化为字符串。常用的库（如 `json.dumps()` 在 Python 中或 `JSON.stringify()` 在 JavaScript 中）会将内存中的数据结构转换为 JSON 字符串。

应用程序通常通过系统调用（如 `send()` 或 `write()`）将数据发送到网络套接字。这些系统调用是操作系统与应用程序之间的接口，允许应用程序通过网络通信。

**示例：Python 中通过 Socket 发送 JSON 数据**

```python
import socket
import json

# 创建TCP socket
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# 连接到服务器
sock.connect(('example.com', 80))

# 构造JSON数据
data = {'name': 'Alice', 'age': 25}
json_data = json.dumps(data)

# 通过网络套接字发送JSON字符串
sock.sendall(json_data.encode('utf-8'))

# 关闭连接
sock.close()
```

在这个阶段，应用程序创建 JSON 数据并调用操作系统的网络接口函数来发送数据。

### 2. **传输层**：数据分段和可靠传输

在操作系统的网络栈中，JSON 数据在发送到网络之前经过传输层（通常是 TCP 或 UDP）处理。TCP 和 UDP 是传输层协议，负责将应用层的数据封装到传输层数据包中。

- **TCP**：在使用 TCP 时，JSON 数据被分段（segmentation）成更小的包。TCP 提供可靠的数据传输，包括错误检测、丢包重传、流量控制等。TCP 保证数据按顺序、无损地到达接收端。
- **UDP**：UDP 则是无连接、非可靠的协议，不保证数据包的顺序和完整性。UDP 适合对实时性要求较高的应用，如视频流。

TCP 和 UDP 都将 JSON 数据作为负载（payload），封装在它们的协议包中。

**数据分段示例：** 假设我们发送的 JSON 字符串有 5000 字节，而 TCP 包的最大负载通常为 1460 字节（典型的 MTU 限制）。TCP 会将 JSON 数据分成多个片段，每个片段加上 TCP 头部后发送。

### 3. **网络层**：IP 包封装与路由

在网络层，传输层的数据包（TCP 或 UDP 包）会进一步被封装到 IP 数据包中。在这一层，操作系统根据目标 IP 地址确定如何路由数据包。网络层协议主要是 IPv4 或 IPv6，它们负责将数据包发送到目标地址。

在这个阶段，JSON 数据的每个段被包含在 IP 数据包的有效载荷中。IP 数据包会被发送到网络接口，网络接口会根据路由表和目标地址决定数据包的转发路径。

### 4. **链路层**：物理传输

在链路层，IP 数据包会被封装成帧，准备通过物理网络（如以太网、Wi-Fi）传输。操作系统通过网络接口驱动程序与硬件设备（如网卡、无线适配器）通信，进行实际的比特传输。

**封装过程：**

- 在以太网环境中，数据包被封装为以太网帧。
- 每一帧包含以太网头部、IP 数据包和帧校验序列。

此时，操作系统通过驱动程序和硬件设备将数据以电信号、光信号或无线电波的形式发送到网络介质上，传输给下一个设备（如路由器或交换机）。

### 5. **接收端的解封装与处理**

当 JSON 数据到达接收端时，接收端的操作系统会逆向执行以上步骤：

- **链路层**：接收网络帧，验证帧完整性。
- **网络层**：解封装 IP 包，检查包头并根据 IP 地址决定如何处理。
- **传输层**：如果使用 TCP，则将收到的多个片段重组为完整的 JSON 字符串。如果是 UDP，则直接处理负载。
- **应用层**：接收端应用程序通过系统调用（如 `recv()` 或 `read()`）从操作系统的网络套接字中读取数据，最后将 JSON 字符串反序列化为应用程序所需的数据结构。

### 6. **数据校验与完整性**

在整个传输过程中，操作系统负责保证数据的完整性和可靠性：

- **传输层**（TCP）会在传输过程中使用校验和（checksum）来检测错误，必要时重传数据。
- **链路层**会通过帧校验序列（FCS）检测链路层的传输错误。

这些机制确保传输过程中 JSON 数据不会被损坏或丢失。

### **总结**

- **应用层**：应用程序通过系统调用（如 `send()`）将 JSON 数据作为字符串通过网络套接字发送。
- **传输层**：传输层（TCP/UDP）将 JSON 数据分段并进行可靠传输。
- **网络层**：网络层（IP）将数据包封装成 IP 包，决定传输路径。
- **链路层**：链路层将 IP 包封装为帧，通过物理网络介质传输。
- **接收端**：接收端的操作系统解封装数据，应用程序读取并反序列化 JSON 数据。

整个过程中，操作系统充当桥梁，将高层的 JSON 格式数据逐步封装并通过物理网络传输，最终解封装并传递给接收端的应用程序。