Go 语言的垃圾回收（GC）算法在其发展过程中经历了多次改进，每个版本都引入了新的优化和策略，以减少 GC 的停顿时间（STW, Stop-The-World）并提高性能。以下是 Go GC 在各个版本中的主要策略和改进：

------

### **Go 1.0 - 1.3: 标记-清除算法（Mark and Sweep）**

- **策略**：
  - 采用传统的标记-清除算法。
  - 在 GC 过程中会暂停整个程序（STW），导致较长的停顿时间。
- **问题**：
  - STW 时间较长，尤其是在堆内存较大时，对延迟敏感的应用（如 Web 服务）影响较大。

------

### **Go 1.4: 引入写屏障（Write Barrier）**

- **策略**：
  - 引入了写屏障（Write Barrier）技术，为并发垃圾回收做准备。
  - 写屏障允许在程序运行的同时，GC 能够正确地跟踪对象的引用关系。
- **改进**：
  - 为后续版本的并发 GC 奠定了基础。

------

### **Go 1.5: 并发标记-清除（Concurrent Mark and Sweep）**

- **策略**：
  - 引入了并发标记-清除算法。
  - **标记阶段**：大部分标记工作与程序并发执行，减少了 STW 时间。
  - **清除阶段**：仍然是并发的，但不会暂停程序。
- **改进**：
  - STW 时间从几百毫秒降低到几十毫秒，显著提高了 GC 的性能。
- **问题**：
  - 仍然存在一定的 STW 时间，尤其是在标记阶段的开始和结束时。

------

### **Go 1.6 - 1.7: 进一步优化并发 GC**

- **策略**：
  - 优化了写屏障和并发标记的实现。
  - 减少了 STW 时间，尤其是在标记阶段的开始和结束时。
- **改进**：
  - STW 时间进一步降低，通常在 1 毫秒以内。

------

### **Go 1.8: 消除清除阶段的 STW**

- **策略**：
  - 完全消除了清除阶段的 STW，使清除工作完全并发。
- **改进**：
  - STW 时间进一步减少，通常低于 100 微秒。

------

### **Go 1.9 - 1.11: 增量式 GC 和栈重扫**

- **策略**：
  - 引入了增量式 GC 和栈重扫（Stack Rescanning）机制。
  - 增量式 GC 将标记工作分成多个小步骤，进一步减少单次停顿时间。
  - 栈重扫机制确保在并发标记过程中，栈上的对象引用能够被正确跟踪。
- **改进**：
  - 进一步降低了 GC 对程序延迟的影响。

------

### **Go 1.12: 自适应 GC 策略**

- **策略**：
  - 引入了自适应的 GC 策略，动态调整 GC 的触发阈值。
  - 根据程序的运行情况，自动调整 `GOGC` 的值，以平衡内存使用和 GC 频率。
- **改进**：
  - 减少了不必要的 GC 触发，提高了程序的整体性能。

------

### **Go 1.14: 抢占式调度与 GC 优化**

- **策略**：
  - 改进了抢占式调度机制，确保长时间运行的 Goroutine 不会阻塞 GC 的进行。
  - 优化了 GC 的标记和清除阶段，进一步减少停顿时间。
- **改进**：
  - 提高了 GC 的响应速度，尤其是在高并发场景下。

------

### **Go 1.15 - 1.17: 持续优化与性能提升**

- **策略**：
  - 持续优化 GC 的标记和清除算法。
  - 改进了内存分配器的性能，减少了内存碎片化。
- **改进**：
  - 进一步降低了 GC 的 CPU 开销和内存开销。

------

### **Go 1.18 及以后：泛型与 GC 优化**

- **策略**：
  - 引入了泛型（Generics），但泛型的引入并未对 GC 算法产生重大影响。
  - 继续优化 GC 的性能，减少停顿时间和 CPU 开销。
- **改进**：
  - 在高并发和大内存场景下，GC 的性能更加稳定。

------

### **总结**

Go 语言的垃圾回收器从最初的标记-清除算法逐步演变为高效的并发标记-清除算法，并通过引入写屏障、增量式 GC、自适应策略等技术，显著减少了 STW 时间和 CPU 开销。以下是各版本的主要改进点：

| 版本       | 主要改进                                 |
| :--------- | :--------------------------------------- |
| Go 1.0-1.3 | 标记-清除算法，STW 时间较长              |
| Go 1.4     | 引入写屏障，为并发 GC 做准备             |
| Go 1.5     | 并发标记-清除，大幅减少 STW 时间         |
| Go 1.8     | 消除清除阶段的 STW                       |
| Go 1.12    | 自适应 GC 策略，动态调整触发阈值         |
| Go 1.14    | 抢占式调度优化，减少 GC 阻塞             |
| Go 1.18+   | 持续优化，提升高并发和大内存场景下的性能 |

Go 的 GC 设计目标是**低延迟和高吞吐量**，适合需要高并发的应用场景（如 Web 服务）。开发者可以通过调整 `GOGC` 环境变量或使用性能分析工具（如 `pprof`）来进一步优化程序的 GC 行为。