# Golang运行时

## 一、运行Go程序过程

Go程序的运行流程与Java有所不同，Go语言在设计上追求简单、高效，因此其编译和执行流程更加直接。以下是操作系统如何运行Go程序的详细过程：

**1、编写Go代码**

​	开发者使用文本编辑器或集成开发环境（IDE）编写Go源代码，文件扩展名为`.go`。

2. **编译Go代码**

与Java的字节码和JVM不同，Go语言是**静态编译型语言**，也就是说Go代码在编译时直接生成与操作系统和硬件平台相关的**本地机器码**，不依赖于虚拟机。

Go语言的编译器将源代码编译成一个**独立的可执行文件**，这个文件包含了程序的全部内容，包括标准库的代码和依赖项，因此Go程序不需要像Java一样依赖外部虚拟机或运行时环境。

**编译示例：**

```bash
go build hello.go
```

这条命令将生成一个可执行文件`hello`（在Linux/macOS上）或`hello.exe`（在Windows上）。这个可执行文件是平台相关的，不能跨平台执行（例如编译出来的Linux二进制文件无法在Windows上直接运行）。

3. **操作系统执行Go程序**

编译好的Go程序是一个可执行文件，直接由操作系统启动并执行，类似于C/C++程序的执行流程。操作系统将该二进制文件加载到内存中，分配资源并启动进程。

**执行示例：**

```bash
./hello
```

4. **Go运行时（Runtime）**

尽管Go语言生成的是独立的可执行文件，但它包含了一个内置的**运行时库**，负责管理一些核心功能，包括：

- **内存管理**：例如垃圾回收（GC）。
- **协程调度**：Go语言的并发模型依赖于轻量级的协程（goroutines），Go运行时内置了一个协程调度器，负责将goroutines映射到系统线程。
- **系统调用封装**： 操作系统提供的系统调用（如文件I/O、网络操作等），Go的运行时库为这些操作提供了封装。

Go运行时在程序的执行过程中提供了类似操作系统的基础服务，但它与Java的JVM不同，Go程序运行时并不依赖外部虚拟机。

5. **协程（Goroutine）与操作系统线程**

Go程序中的并发操作是通过**goroutines**实现的。Goroutine是Go语言中极轻量级的线程，它比操作系统的线程更轻，占用资源更少。

- Goroutines与系统线程：Go的运行时负责将大量的goroutines调度到少量的操作系统线程上执行。这个调度器通过M调度模型工作，即多个goroutines可以被映射到N个系统线程上。

  

- 操作系统只需要管理Go运行时生成的系统线程，而不直接处理每个goroutine。因此，操作系统感知到的并发是线程级别的，而Go运行时则负责管理goroutines的并发。

6. **垃圾回收（GC）**

Go程序包含内置的垃圾回收器（GC），自动管理内存的分配和回收。Go的GC会在程序运行过程中周期性地回收不再使用的内存。虽然垃圾回收器是Go运行时的一部分，但实际的内存管理依然是通过操作系统提供的接口进行的。

7. **系统调用与操作系统交互**

Go程序通过操作系统的系统调用接口（如POSIX API）与底层资源交互，包括文件系统、网络、内存等。Go标准库封装了这些系统调用，以简化开发者的工作。

例如，操作系统管理文件时，Go标准库的`os`包通过系统调用与操作系统进行交互。

8. **程序退出**

当Go程序执行完毕时，它会退出主协程（main goroutine），运行时会自动进行清理工作，包括释放内存、关闭文件句柄等。操作系统在程序退出时回收该进程使用的资源。

总结

操作系统运行Go程序的流程大致如下：

1. **编写Go代码**。
2. **编译**成独立的本地可执行文件。
3. 操作系统直接运行编译后的可执行文件，启动一个新的进程。
4. Go的运行时库负责协程调度、内存管理等工作。
5. Go程序通过系统调用与操作系统交互，进行I/O、网络、文件操作等。
6. 程序执行结束后，操作系统回收资源。

与Java不同，Go程序无需依赖虚拟机，也不需要字节码解释或即时编译（JIT），其编译后的可执行文件直接包含了所有依赖，因而运行时效率较高。





## 二、GC

#### 1、GC算法

* Go V1.3之前的标记-清除(mark and sweep)算法
* Go V1.5的三色并发标记法
* Go V1.8的混合写屏障(hybrid write barrier)机制



## 三、协程管理