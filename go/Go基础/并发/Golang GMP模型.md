# Golang GMP模型

Golang 的 GMP 模型是 Go 语言运行时的核心调度模型，用于管理 Goroutine 的执行。GMP 模型的设计目标是通过高效的调度机制来充分利用多核处理器的并行性，从而提高程序的性能和并发性。以下是对 GMP 模型的详细说明：

### GMP 模型的基本组成部分

- **G (Goroutine)**：Goroutine 是 Go 语言中的轻量级线程，负责执行用户代码。每个 Goroutine 都包含一个栈和一些必要的上下文信息。Goroutine 在程序中独立运行，允许程序进行高并发的任务处理。
- **M (Machine/OS Thread)**：M 表示操作系统线程。M 负责真正执行 Goroutine 的代码。一个 M 可以执行多个 G，M 是 Go 运行时与操作系统之间的桥梁。M 代表了系统层的执行单元。
- **P (Processor/Processor Context)**：P 表示处理器，包含 Goroutine 的本地队列和调度上下文。P 是 G 和 M 之间的调度器，每个 P 都与一个 M 绑定，M 只有获取了 P 才能执行 G。P 的数量通过环境变量 `GOMAXPROCS` 控制，默认情况下等于 CPU 核心数。

### GMP 模型的工作机制

1. **调度器初始化**：Go 运行时根据 `GOMAXPROCS` 参数创建一定数量的 P，并且为每个 P 分配 Goroutine 的本地队列。
2. **Goroutine 创建**：用户通过 `go` 关键字创建新的 Goroutine，这些 Goroutine 会被放入当前 P 的本地队列中，等待调度器调度执行。
3. **Goroutine 调度**：
   - 调度器从 P 的本地队列中选取一个 Goroutine（G），然后把 G 分配给绑定的 M 执行。
   - 如果 M 上没有可以执行的 Goroutine，M 可能会从全局队列或其他 P 的队列中窃取任务。
   - 如果 P 的本地队列满了，P 会将一些 Goroutine 推送到全局队列，供其他 P 使用。
4. **G 和 M 的关联**：每个 M 在运行时绑定到一个 P，只有获得 P 的 M 才能执行 G。当一个 M 由于系统调用或阻塞操作（例如 IO）挂起时，调度器可能会将该 M 解除绑定，让其他 M 来接管 P 和 G 的执行。
5. **阻塞与唤醒**：当 M 执行的 Goroutine 被阻塞（如等待 IO），运行时会把该 M 挂起并让其他 M 接管执行。M 完成阻塞操作后会被唤醒并恢复执行。

### GMP 模型的并发特点

- **并行执行**：由于多个 M 绑定不同的 P，同时执行不同的 G，GMP 模型可以充分利用多核 CPU，达到并行执行的效果。
- **工作窃取**：当某个 P 上的任务执行完毕，调度器会从其他 P 或全局队列中窃取任务，以保持各个处理器的负载均衡。
- **轻量级**：Goroutine 是非常轻量级的，相比于传统的操作系统线程，Goroutine 占用更少的内存和资源，调度的代价也更低。

### 总结

Golang 的 GMP 模型是通过将 Goroutine (G)、操作系统线程 (M) 和调度上下文 (P) 分离，来实现高效的并发调度机制。通过这种设计，Go 运行时可以在多核系统上高效地并行执行多个 Goroutine，减少阻塞和等待的影响，实现高效并发编程。

这种模型确保了 Go 程序的并发性能，并通过简化并发编程模型，让开发者能够更容易编写并发代码，而无需关心底层线程的管理。