# 线程与golang协程调度上的区别

Go语言中的协程（称为**goroutine**）与传统的线程在调度上的区别主要体现在调度机制、执行方式和系统资源管理上。Go的**goroutine**调度采用了一种独特的方式，旨在优化并发编程的性能。以下是Go协程和传统线程调度的区别：

### 1. **线程调度**

#### **传统线程的特点**

- **内核级线程**：线程是由操作系统管理的，通常是内核级的调度单位。操作系统的调度器决定哪个线程在何时运行，并通过抢占式调度（preemptive scheduling）管理多个线程。
- **并行执行**：操作系统线程可以在多个CPU核心上同时并行执行，线程调度由操作系统的调度器处理。操作系统可以将不同线程分配到不同的核心上，从而实现并行性。
- **上下文切换**：线程的上下文切换需要保存和恢复大量的状态信息（如寄存器、堆栈指针等），并且涉及从用户态切换到内核态。这种上下文切换开销较大，频繁的切换可能会影响系统性能。
- **内存开销**：每个线程通常都有自己的栈内存空间（例如，几MB大小），这意味着在创建大量线程时，内存消耗会迅速增加。

### 2. **Goroutine调度**

#### **Goroutine的特点**

- **用户级调度**：Goroutine是Go语言中实现的轻量级用户级线程，由Go语言的**运行时调度器**管理，而不是由操作系统的内核调度器管理。它们比操作系统线程更加轻量，调度更加高效。
- **高效的并发**：Goroutine的栈大小非常小，初始值通常只有几KB，并且可以动态扩展。这使得创建大量goroutine比创建大量线程更加高效，尤其适用于大规模并发场景。
- **协作式调度和抢占式调度结合**：最初，goroutine主要依赖于协作式调度，即goroutine在需要时显式地让出执行权。然而，在Go 1.14版本之后，Go增加了**抢占式调度**的能力，当某个goroutine运行时间过长时，Go运行时系统可以强制切换到其他goroutine，避免阻塞整个调度系统。

#### **Go的M调度模型**

- Go语言使用了一个

  M

  调度模型

  ，即将M个goroutine映射到N个操作系统线程上。这种模型通过一个用户态的调度器管理goroutine在操作系统线程上的执行。

  - **M (Goroutine)**：这是Go中的轻量级协程，每个goroutine是一个独立的执行单元，可以由用户级调度器控制。
  - **N (OS Thread)**：Go运行时将多个goroutine分配到少量的操作系统线程上运行，操作系统线程数量远小于goroutine的数量。

- **P (Processor)**：Go的调度模型引入了一个抽象的概念叫做**P (Processor)**，它代表了一个执行goroutine的执行环境。P的数量决定了可以同时活跃运行的goroutine的数量（类似于最大并行数）。每个P与一个OS线程绑定，调度器会将goroutine分配给这些P进行执行。

### 3. **调度过程比较**

#### **线程调度**

- **操作系统负责调度**：传统的操作系统线程调度是由操作系统内核完成的，基于抢占式调度，线程可以在任何时候被内核中断并切换到另一个线程。
- **时间片轮转**：线程调度依赖时间片，当时间片耗尽时，操作系统会强制线程让出CPU。这种调度方式可以在多核环境下实现真正的并行，但上下文切换的开销较大。
- **适用于多核并行**：由于线程调度是操作系统级的，线程可以分布在多个CPU核心上执行，利用多核系统的并行计算能力。

#### **Goroutine调度**

- **Go运行时调度器负责调度**：goroutine的调度是由Go语言的运行时调度器（用户级调度器）管理的。该调度器在用户态中运行，因此上下文切换的开销远小于线程切换。
- **协作与抢占结合**：goroutine调度最初是协作式的，意味着一个goroutine必须显式让出执行权给其他goroutine。但自Go 1.14起，增加了抢占式调度支持，运行时调度器可以在合适的时机抢占运行时间过长的goroutine。
- **基于P的模型**：Go的调度器会将多个goroutine分配到有限的P上执行。P可以被看作是执行goroutine的上下文，多个goroutine被循环分配到这些P上，并通过底层的N个OS线程执行。调度器负责平衡P与OS线程之间的负载。
- **任务窃取（Work Stealing）**：Go调度器采用了任务窃取算法，当某个P中的goroutine队列耗尽时，它会尝试从其他P的队列中窃取任务，从而保持CPU核心的高效利用。

### 4. **性能与资源管理**

- **上下文切换开销**：由于goroutine的调度发生在用户态，而不涉及用户态与内核态的切换，因此其上下文切换的开销要远小于操作系统线程的切换。goroutine的栈可以动态扩展，初始栈大小非常小，意味着可以轻松创建数以万计的goroutine而不会耗尽内存资源。

- **并发与并行**：虽然goroutine可以在单个线程内并发执行，但通过Go的M

  

  模型，它们可以在多个操作系统线程上分布执行，从而在多核CPU上实现并行。goroutine的调度器自动管理这一过程，开发者无需关心底层的线程管理。

  

- **资源消耗**：创建一个操作系统线程通常需要较多的资源，如几MB的栈内存和内核管理的控制块，而创建一个goroutine的开销极小，通常只需要几KB的栈空间，并且栈可以动态扩展。因此，Go语言更适合处理大规模并发任务。

### 5. **应用场景对比**

- 传统线程

  ：

  - 适用于需要并行处理、充分利用多核CPU的场景，尤其是在计算密集型任务中。
  - 更适合直接与操作系统交互的低级并发操作，例如需要细粒度控制线程的生命周期、优先级和调度策略的应用。

- Go语言的goroutine

  ：

  - 更适合处理大量并发任务的场景，尤其是I/O密集型应用（如网络服务、Web服务器等），可以在单个进程中高效管理数以万计的并发任务。
  - 由于goroutine轻量且调度效率高，适用于构建高并发的应用程序，如微服务架构中的并发处理、协作任务和事件驱动模型等。

### 6. **总结**

- **传统线程**依赖操作系统内核进行调度，具有抢占式调度和多核并行的优势，但上下文切换开销较大，资源消耗较多。

- **Goroutine**则是用户态的轻量级协程，由Go运行时调度器管理，调度开销非常小，可以高效地处理大量并发任务。通过M

  

  调度模型，Go语言的调度器将大量goroutine映射到较少的操作系统线程上，极大地优化了资源使用。

  

Go的goroutine设计极大地简化了并发编程，结合了协作式与抢占式调度的优点，提供了高效的并发处理能力，而不需要开发者手动管理线程的复杂性。