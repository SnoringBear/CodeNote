MySQL 的索引底层主要是基于 **B+ 树** 和 **哈希表** 来实现的，具体的存储结构和索引优化策略取决于存储引擎，例如 InnoDB 和 MyISAM 主要使用 **B+ 树索引**，而 Memory 引擎则可以使用 **哈希索引**。以下是 MySQL 索引底层的实现方式：



## 1. **B+ 树索引（B+Tree Index）**

### 1.1 **数据结构**

- B+ 树是一种 **平衡多路搜索树**，每个节点可以有多个子节点。
- **叶子节点** 存储所有数据行的索引值，并且按顺序排列，同时通过 **双向链表** 连接，提高范围查询的效率。
- **非叶子节点** 仅存储索引键和子节点指针，不存储实际数据，提高查询效率。

### 1.2 **索引的存储方式**

- **主键索引（聚簇索引）**：InnoDB 表的主键索引（PRIMARY KEY）是 **B+ 树索引**，叶子节点存储的是 **完整的行数据**。
- **二级索引（非聚簇索引）**：对于非主键索引（如普通索引、唯一索引），B+ 树的叶子节点存储的是 **主键的值**，需要再回表查询获取完整数据。

### 1.3 **查询过程**

1. 从根节点开始，进行 **二分查找**，找到合适的子节点。
2. 递归遍历子节点，直到找到叶子节点的目标数据。
3. 如果是 **非聚簇索引**，需要再根据主键回表查询完整数据（即“回表”）。

------

## 2. **哈希索引（Hash Index）**

### 2.1 **数据结构**

- 采用 **哈希表** 进行索引，存储的是键值对 (`key -> value`) 形式。
- 通过 **哈希函数计算索引值**，然后直接定位到数据所在的存储位置。

### 2.2 **存储方式**

- 适用于 **Memory 存储引擎**，主要用于 **等值查询**，例如 `=` 或 `IN` 。
- **哈希冲突** 可能会导致 **链地址法** 或 **开放寻址法** 进行冲突处理。

### 2.3 **查询过程**

1. 计算查询键的哈希值 `hash(key) → index`。
2. 通过哈希索引 **直接定位** 数据位置。
3. 由于 **哈希索引无序**，不支持范围查询（如 `BETWEEN`、`ORDER BY`）。

------

## 3. **全文索引（Full-text Index）**

- 主要用于 **全文搜索**，基于 **倒排索引（Inverted Index）** 实现。
- 适用于 **MATCH ... AGAINST** 查询，而非普通 `LIKE '%keyword%'` 查询。
- 可用于 **MyISAM 和 InnoDB**。

------

## 4. **索引优化**

### 4.1 **覆盖索引（Covering Index）**

- 只查询索引中的字段，不需要回表查询，减少 IO 开销。
- 例如 `SELECT id, name FROM users WHERE name = 'Tom'`，如果 `name` 字段有索引，则可以直接在索引中找到数据。

### 4.2 **索引下推（Index Condition Pushdown, ICP）**

- MySQL 5.6 引入，在索引扫描时提前过滤不符合条件的记录，减少回表次数，提高查询效率。

### 4.3 **前缀索引**

- 仅对字符串的前 N 个字符创建索引，减少索引大小。

------

## 5. **总结**

- InnoDB 使用 **B+ 树** 作为主键索引，叶子节点存储完整行数据（聚簇索引）。
- **普通索引（二级索引）** 叶子节点存储主键值，查询时可能需要回表查询。
- **哈希索引** 适用于等值查询，但不支持范围查询。
- **全文索引** 采用 **倒排索引**，适用于文本搜索。

索引的底层实现影响 MySQL 的查询性能，合理使用索引可以大大提高查询效率。